from network.utils import bbox_overlap, compute_bbox_deltas, remove_zero_padding
import tensorflow as tf

class DetectionTargetLayer(tf.keras.Model):
    """Post-process the raw region proposals output by the ProposalLayer during
    training, to ensure a good mix of positive proposals, that substantially overlap
    with a ground-truth bounding box, and negative proposals, that don't overlap
    much with any bounding box.

    Parameters
    ----------
    num_train_roi : int
        Total number of target ROI during training. Should be less than or equal
        to the total number of ROI proposals generated by ProposalLayer. Defaults
        to 256.
    fraction_pos_roi : float
        We will try to ensure that this fraction of num_train_roi are "positive"
        examples (i.e., substantially overlap a ground-truth box). Defaults to 0.5.
    truth_overlap_thresh : float
        Threshold (in terms of IoU) determining whether an ROI overlaps enough with
        a ground-truth box to count as positive. Defaults to 0.7.
    """
    def __init__(self, num_train_roi=256, fraction_pos_roi=0.5, 
                 truth_overlap_thresh=0.7):
        super().__init__()
        self.num_train_roi = num_train_roi
        self.fraction_pos_roi = fraction_pos_roi
        self.truth_overlap_thresh = truth_overlap_thresh

    def call(self, input_data):
        """
        Parameters
        ----------
        input_data : list of tensors
            - ROI proposals in normalized coordinates, [N, num_rois, (y1, x1, y2, x2)]
            - Class scores of each ground-truth box, [N, num_truth]
            - Bounding box of each ground-truth object, [N, num_truth, (y1, x1, y2, x2)]
        Returns
        -------
        list of tensors
            proposed roi, target class indices, and target bounding boxes, 
            dimensions [N, num_train_roi, (y1, x1, y2, x2))], [N, num_train_roi], 
            [N, num_train_roi, (dy, dx, log(dh), log(dw))], respectively.
        """
        proposals, true_classes, true_bboxes = input_data

        [roi, target_classes, target_deltas] = tf.map_fn(
            self.get_targets, [proposals, true_classes, true_bboxes], 
                               dtype=(tf.float32, tf.int32, tf.float32))
        return [roi, target_classes, target_deltas]

    def get_targets(self, input_data):
        proposals, true_classes, true_bboxes = input_data

        # Remove any zero pading or zero area boxes, so we don't need to worry 
        # about divisions by zero when computing IoU, etc.
        proposals, _ = remove_zero_padding(proposals)
        true_bboxes, true_non_zero = remove_zero_padding(true_bboxes)
        true_classes = tf.boolean_mask(true_classes, true_non_zero)

        overlaps = bbox_overlap(proposals, true_bboxes)

        # Determine positive and negative ROIs, based on ground-truth IoU overlap
        proposal_iou_max = tf.reduce_max(overlaps, axis=1)
        pos_indices = tf.where(proposal_iou_max>=self.truth_overlap_thresh)[:, 0]
        neg_indices = tf.where(proposal_iou_max<1-self.truth_overlap_thresh)[:, 0]

        # Maintain the right fraction of positive/negative, even if we don't have
        # enough positive samples (we will zero pad at the end) 
        pos_count = int(self.num_train_roi*self.fraction_pos_roi)
        rand_pos_indices = tf.random_shuffle(pos_indices)[:pos_count]
        pos_count = tf.shape(rand_pos_indices)[0]
        ratio = (1-self.fraction_pos_roi)/self.fraction_pos_roi
        neg_count = tf.cast(tf.ceil(ratio*tf.cast(pos_count, tf.float32)), tf.int32)
        rand_neg_indices = tf.random_shuffle(neg_indices)[:neg_count]
        neg_count = tf.shape(rand_neg_indices)[0]
        pos_roi = tf.gather(proposals, rand_pos_indices)
        neg_roi = tf.gather(proposals, rand_neg_indices)

        # For positive ROI, figure out which ground-truth box we most belong to
        pos_overlap = tf.gather(overlaps, rand_pos_indices)
        pos_truth_indices = tf.argmax(pos_overlap, axis=1)
        pos_truth_boxes = tf.gather(true_bboxes, pos_truth_indices)
        pos_truth_classes = tf.gather(true_classes, pos_truth_indices)
        pos_truth_deltas = compute_bbox_deltas(pos_roi, pos_truth_boxes)

        roi = tf.concat([pos_roi, neg_roi], axis=0)
        padding = tf.maximum(self.num_train_roi-tf.shape(roi)[0], 0)
        roi = tf.pad(roi, [(0, padding), (0, 0)])
        target_classes = tf.pad(pos_truth_classes, [(0, neg_count)])
        target_classes = tf.pad(target_classes, [(0, padding)], constant_values=-1)
        target_deltas = tf.pad(pos_truth_deltas, [(0, padding+neg_count), (0, 0)])

        return roi, target_classes, target_deltas