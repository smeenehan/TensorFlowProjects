import tensorflow as tf

class ROIAlign(tf.keras.Model):
    """Generate ROI features by pooling a feature map to a specified size.

    Parameters
    ----------
    pool_shape : list of ints
        Shape ([height, width]) of the ROI features generated by pooling. Defaults
        to [7, 7].
    """
    def __init__(self, pool_shape=[7, 7]):
        super().__init__()
        self.pool_shape = pool_shape

    def call(self, input_data):
        """
        Parameters
        ----------
        input_data : list of tensors
            - Feature map output by the backbone network, [N, height, width, channels]
            - ROI produced by the RPN + proposal layers; may contain zero ROIS if
              we had to pad to num_rois, [N, num_rois, (y1, x1, y2, x2)] in 
              normalized coordinates
        Returns
        -------
        tensor
            Pooled ROI, [N, num_rois, height, width, channels], height and width
            specified by pool_shape.
        """
        feature_map = input_data[0]
        roi = input_data[1]

        """Unlike the Mask R-CNN paper, we only interpolate a single value from 
        the feature map for each ROI feature pixel, rather than sampling four and 
        pooling. According to the paper this shouldn't matter to much."""
        def roi_align(x):
            features = x[0]
            boxes = x[1]
            features = tf.expand_dims(features, 0)
            inds = tf.zeros(tf.shape(boxes)[0], tf.int32)
            return tf.image.crop_and_resize(features, boxes, inds, self.pool_shape,
                                            method='bilinear')

        roi_features = tf.map_fn(roi_align, [feature_map, roi], dtype=tf.float32)

        return roi_features

class ROIHead(tf.keras.Model):
    """Classify ROI feature vectors and provide bounding box refinements for each
    class.

    Parameters
    ----------
    Parameters
    ----------
    data_format : string
        'channels_first' or 'channels_last', indicating the ordering of feature
        maps and channels.
    pool_shape : list of ints
        Shape ([height, width]) of the ROI features generated by pooling. Defaults
        to [7, 7].
    num_channels : int
        Number of channels after convolutional stage. Defaults to 256.
    num_classes : int
        Number of classes. Defaults to 20. Should include extra class for background.
    hidden_dim : int
        Dimension of hidden layers. Defaults to 1024.
    regularizer : function
        Regularizer function applied to all weights in the network. Defaults to
        None.
    """
    def __init__(self, data_format, pool_shape=[7, 7], num_channels=256, 
                 num_classes=20, hidden_dim=1024, regularizer=None,):
        super().__init__()
        self.conv = tf.keras.layers.TimeDistributed(tf.keras.layers.Conv2D(
            num_channels, pool_shape, data_format=data_format, use_bias=False, 
            padding='same', kernel_regularizer=regularizer))
        bn_axis = 1 if data_format is 'channels_first' else 3
        self.bn = tf.keras.layers.TimeDistributed(tf.layers.BatchNormalization(
            axis=bn_axis, name='bn'))
        self.fc1 = tf.keras.layers.TimeDistributed(tf.keras.layers.Dense(
            hidden_dim, name='fc1'kernel_regularizer=regularizer))
        self.fc2 = tf.keras.layers.TimeDistributed(tf.keras.layers.Dense(
            hidden_dim, name='fc2'kernel_regularizer=regularizer))
        self.fc_class = tf.keras.layers.TimeDistributed(tf.keras.layers.Dense(
            num_classes, name='fc_class',kernel_regularizer=regularizer))
        self.fc_bbox = tf.keras.layers.TimeDistributed(tf.keras.layers.Dense(
            4*num_classes, name='fc_bbox',kernel_regularizer=regularizer))

    def call(self, input_data, training=False):
        """
        Parameters
        ----------
        input_data : tensor
            ROI feature maps produced by the ROIAlign layer, 
            [N, num_rois, height, width, channels]
        Returns
        -------
        list of tensors
            logits and bounding box refinements for each ROI, dimensions
            [N, num_roi, num_classes], [N, num_roi, 4*num_classes], respectively.
        """
        x = self.conv(input_data)
        x = self.bn(x, training=training)
        x = tf.nn.relu(x)
        x = tf.squeeze(x, axis=[2, 3])
        x = self.fc1(x)
        x = tf.nn.relu(x)
        x = self.fc2(x)
        x = tf.nn.relu(x)
        class_logits = self.fc_class(x)
        bbox = self.fc_bbox(x)
        return [class_logits, bbox]

